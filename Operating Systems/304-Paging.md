# Paging
---
- Paging is another memory management scheme that also permits the phyisical address space of a process to be noncontiguous.
- However paging avoids external fragmentation and need for compaction, whereas segmentation does not. 
- It also solves the problem of fitting memory chunks of varying sizes onto the backing store. The problem arises because, when code fragments or data residing in main memory need to be swapped out, space must be found on the backing store
- The backing store has the same fragmentation problems discussed in connection with main memory, but access is much slower, so compaction is impossible

## Basic Method
- The basic method for implementing paging involves breaking physical memory into fixed-size blocks called frames and breaking logical memory into blocks of the same size called pages
- When a process is to be executed, its pages are loading into any available memory frames from their source (file system or backing store)
- The backing store is divided into fixed-sized blocks that are the same size as the memory frames or clusters of multiple frames
- The logical address space is now totally seperate from the physical address space, so a process can have 64-bit address space even though the systemm has less than `2^64` bytes of physical memory

![[basicmet.png]]
![basicmet](https://github.com/Shogunkayo/PES_Notes/blob/main/Operating%20Systems/images/basicmet.png)

- Every address generated by the CPU is divided into two parts
- Page number `p` is used as an index into a page table which contains the base address of each page in physical memory
- Page offset `d` is combined with the base address to define the physical memory address that is sent to the memory unit

![[pagemodel.png]]

![pagemodel](https://github.com/Shogunkayo/PES_Notes/blob/main/Operating%20Systems/images/pagemodel.png)

- The page size is defined by the hardware.  Size of a page is a power of 2. The selection of a power of 2 as a page size makes the translation of a logical address into a page number and page offset particularly easy

- Slow and internal fragmentation
- Translation Lookaside Buffer
- TLD hit and miss 
- Shared code and private code
- 3 types:
1. Heirarchical page table
	- Outer page table acts as index for inner page table
	- 2 page numbers for two-level paging scheme
	- If the memory increases, multiple page tables are required
	- Also called forward-mapped page table
2. Hashed page table
	- Hash table with linked lists
	- Linked list contains 3 fields
3. Inverted page table
	- Two columns in page table: pid and page number