# Memory Management
---
- Memory consists of a large array of bytes each with its own address
- The instruction is first fetched from memory. The instruction is then decoded and may cause operands to be fetched from memory. After the instruction has been executed on the operands, results may be stored back in memory
- Memory unit is concerned only about the sequence of memory addresses generated, not how it is generated
- When multiple processes are running, there might be race conditions

## Basic Hardware
- Main memory and the registers built into the processor itself are the only general purpose storage that the CPU can access directly
- If the data are not in memory, they must be moved there before the CPU can operate on them
- Registers that are built into the CPU are generally accessible within one cycle of the CPU clock. The same cannot be said of main memory, which is accessed via a transaction on the memory bus. Completing a memory access may take many cycles of the CPU clock -> processor normally needs to stall. To avoid this, cache is built into the CPU. The hardware automatically sppeds up memory access without any operating system control

For proper system operationg, we must protect the operating system from access by user processes. This protection must be provided by the hardware because the operating system doesn't intervene between the CPU and its memory accesses (due to performance penalty)
- Each process has a seperate memory space
- To seperate memory spaces, two registers are used -> base and limit
- Base register holds the smallest legal physical memory address
- Limit register specifies the size of the range
- The base and limit registers can be loaded only by the operating system using a special privileged instruction which can be executed only in kernel mode. The operating system can change the value of the registers but not the user programs

![[memory_space.png]]

- Protection of memory space is achieved by having the CPU hardware compare every address generated in user mode with the registers
- If a program executing in user mode attempts to access operating system memory or other users' memory, it results in a trap to the operating system

![[addr_prot.png]]

## Address Binding
Usually a program resides on a disk as a binary executable file. To be executed, the program must be brought into memory and placed within a process. Depending on the memory management, the process may be moved between disk and memory during its execution
- The processes on the disk that are waiting to be brought into memory for execution form the input queue 
- One of the processes in the input queue is selected from input queue and loaded into memory. As the process is executed, it accesses instructions and data from memory. Eventually the process terminates and its memory space is declared available
- Addresses in the source program are generally symbolic. A compiler typically binds these symbolic addresses to relocatable addresses (like from a variable called `count` to "14 bytes from the begining of this module")
- The loader binds the relocatable addresses to absolute addresses (like `74014`)
- The binding can be done in any of the following steps

![[multistep.png]]

### Compile Time
- If you know at compile time where the process will reside in memory, then absolute code can be generated
- If, at some later time, the starting location changes, then the code has to be recompiled
- `MS-DOS .COM` format programs are bound at compile time

### Load Time
- If it is not known at compile time where the process will reside in memory, then the compiler must generate relocatable code
- Final binding is delayed until load time
- If the starting address changes, the code has to be reloaded

### Execution Time
- If the process can be moved during its execution from one memory segment to another, then binding must be delayed until run time
- Special hardware must be available
- Most general-purpose operating systems use this method

## Logical and Physical Address Space
- An address generated by the CPU is referred to as a logical address (also called virtual address). The set of all logical addresses generated by a program is a logical address space
- An address seen by the memory unit (the one loaded into the memory address register of memory) is referred to as a physical address. The set of all physical addresses corresponding to the logical addresses is a physical address space
- The run time mapping is done by a hardware device called the memory management unit (MMU)

![[logphys.png]]

- The base register is called as relocation register. The value in the relocation register is added to every address generated by a user process
- The user program never sees the real physical addresses

## Dynamic Loading
- A routine is not loaded until it is called. All routines are kept on disk in a relocatable load format
- When a routine needs to call another routine, the calling routine first checks to see whether the other routine has been loaded
- This method is useful when large amounts of code are needed to handle infrequently occuring cases (like error routines)

## Dynamic Linking
- In static linking, system libraries are treated like any other object module and are connected by the loader into the binary program image
- Dynamically linked libraries are system libraries that are linked to user programs when programs are run
- Linking is postpooned uuntil execution time
- Piece of code called stub is included in the image for each library routine reference. It indicaes how to locate the appropriate memory resident library routine or how to load the library if the routine is not already present
- When the stub is executed, it checks to see whether the needed routine is already in memory. If it is not, the program loads the routine into memory. Either way, the stub replaces itself with the address of the routine and executes the routine

## Shared Libraries
- A library may be replaced by a new version, and all programs that reference the library will automatically use the new version
- Version information is included in both the program and the library so that programs will not accidently execute new, incompatible versions of libraries. 
- Only programs that are compiled with the new library version are affected by any incompatible changes incorporated in it. Other programs linked before the new library was installed will continue using the older library
- This system is called shared libraries
- Unlike dynamic loading, dynamic linking and shared libraries require help from the operating system